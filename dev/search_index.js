var documenterSearchIndex = {"docs":
[{"location":"tests/#Tests","page":"Tests","title":"Tests","text":"","category":"section"},{"location":"tests/#@","page":"Tests","title":"@↓","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"using Revise, ArrowMacros, ExtractMacro, UnPack, BenchmarkTools\nBenchmarkTools.DEFAULT_PARAMETERS.samples = 1_000_000\nmutable struct A; a; b; c; end\nmutable struct B; d; e; end\ns = A(1, [2, 3], B(4, [5, 6]))\nv = [s]","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Extract a field from a struct:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a\n# 27.797 ns (0 allocations: 0 bytes)\n@btime @unpack a = s\n# 18.437 ns (0 allocations: 0 bytes)\n@btime @↓ a = s\n# 18.428 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Extract a field from a vector of structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract v[1] : a\n# 49.558 ns (0 allocations: 0 bytes)\n@btime @unpack a = v[1]\n# 36.833 ns (0 allocations: 0 bytes)\n@btime @↓ a = v[1]\n# 34.892 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Extract more than one fields from a struct:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a b\n# 51.711 ns (0 allocations: 0 bytes)\n@btime @unpack a, b = s\n# 35.136 ns (0 allocations: 0 bytes)\n@btime @↓ a, b = s\n# 35.544 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Extract whilst doing some maths:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a = 2a\n# 45.942 ns (0 allocations: 0 bytes)\n@btime @↓ a ← 2a = s\n# 35.529 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Extract into differently named variables:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Note that there is an issue between ArrowMacros and BenchmarkTools for which the expression below is not parsed correctly. On the other hand, the same expression works just fine with @time.","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a = b .+ 1 b\n# 435.237 ns (3 allocations: 144 bytes)\nf() = @↓ a ← b .+ 1, b = s\n@btime f()\n# 417.050 ns (3 allocations: 144 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Extract from nested structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s.c : d e\n# 111.674 ns (0 allocations: 0 bytes)\n@btime @unpack d, e = s.c\n# 64.945 ns (0 allocations: 0 bytes)\n@btime @↓ d, e = s.c\n# 62.787 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/#@-2","page":"Tests","title":"@↑","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"@↓ a, b, c = s\n@↓ e, d = c","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Insert a variable into a struct:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! s = a\n# 176.963 ns (1 allocation: 16 bytes)\n@btime @↑ s = a\n# 24.577 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Insert a variable into a vector of structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! v[1] = a\n# 194.824 ns (1 allocation: 16 bytes)\n@btime @↑ v[1] = a\n# 39.872 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Insert more than one variables into a struct:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! s = a, b\n# 226.328 ns (1 allocation: 32 bytes)\n@btime @↑ s = a, b\n# 44.901 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Insert into nested structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! s.c = d, e\n# 272.644 ns (1 allocation: 32 bytes)\n@btime @↑ s.c = d, e\n# 70.399 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/#@-3","page":"Tests","title":"@←","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"Leave the expression unchanged:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"f(x) = x\n@btime a = f(2)\n# 0.027 ns (0 allocations: 0 bytes)\n@btime @← a = f(3)\na\n# 0.027 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Switch to in-place syntax:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Some overhead is present due to f! = Symbol(f, \"!\"), as shown below:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"a = 0\np!(a, b) = a = b\n@btime p!(a, 1)\n# 0.027 ns (0 allocations: 0 bytes)\n@btime @← a = p(1)\n# 86.807 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"However, this overhead becomes negligible for big-enough problems:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"a = zeros(1000);\np!(a, b) = a .= b\n@btime p!(a, 1)\n# 102.673 ns (0 allocations: 0 bytes)\n@btime @← a = p(1)\n# 92.511 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#NSDEBase.jl","page":"Home","title":"NSDEBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of NSDEBase.jl, a Julia package providing the macros @↓, @↑, @⤓, @⤒, and @←.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 3","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All exported types and functions are considered part of the public API and thus documented in this manual.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ArrowMacros]","category":"page"},{"location":"#ArrowMacros.@←-Tuple{Any}","page":"Home","title":"ArrowMacros.@←","text":"@← a = f(b...)\n\nreturns either a = f(b...) or f!(a, b...), in this order.\n\n\n\n\n\n","category":"macro"},{"location":"#ArrowMacros.@↑-Tuple{Any}","page":"Home","title":"ArrowMacros.@↑","text":"@↑ s = a, c ← f(b)\n\ninserts vs into structs' fields.\n\n\n\n\n\n","category":"macro"},{"location":"#ArrowMacros.@↓-Tuple{Any}","page":"Home","title":"ArrowMacros.@↓","text":"@↓ a, c ← f(b) = s\n\nextracts fields from structs.\n\n\n\n\n\n","category":"macro"},{"location":"#ArrowMacros.@⤒-Tuple{Any}","page":"Home","title":"ArrowMacros.@⤒","text":"@⤒ s = a, c ← f(b)\n\npacks objects into mutable composite types or subfields.\n\n\n\n\n\n","category":"macro"},{"location":"#ArrowMacros.@⤓-Tuple{Any}","page":"Home","title":"ArrowMacros.@⤓","text":"@⤓ a, c ← f(b) = s\n\nunpacks objects from composite types or subfields.\n\n\n\n\n\n","category":"macro"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
