var documenterSearchIndex = {"docs":
[{"location":"tests/#Tests","page":"Tests","title":"Tests","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"All tests were run in the REPL with Julia 1.6 using an Apple M1 Pro chip.","category":"page"},{"location":"tests/#@","page":"Tests","title":"@↓","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"using Revise\nusing ArrowMacros, ExtractMacro, UnPack\nusing BenchmarkTools","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"BenchmarkTools.DEFAULT_PARAMETERS.samples = 1_000_000\nmutable struct A; a; b; c; end\nmutable struct B; d; e; end\ns = A(1, [2, 3], B(4, [5, 6]))\nv = [s]","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Download a field from a struct:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a\n# 25.226 ns (0 allocations: 0 bytes)\n@btime @unpack a = s\n# 18.388 ns (0 allocations: 0 bytes)\n@btime @↓ a = s\n# 18.180 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Download from a vector of structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract v[1] : a\n# 44.910 ns (0 allocations: 0 bytes)\n@btime @unpack a = v[1]\n# 36.836 ns (0 allocations: 0 bytes)\n@btime @↓ a = v[1]\n# 37.760 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Download multiple fields:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a b\n# 44.571 ns (0 allocations: 0 bytes)\n@btime @unpack a, b = s\n# 32.519 ns (0 allocations: 0 bytes)\n@btime @↓ a, b = s\n# 33.157 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Download whilst doing some maths:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a = 2a\n# 48.245 ns (0 allocations: 0 bytes)\n@btime @↓ a ← 2a = s\n# 41.204 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Download with different names:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"For some reason, @↓ a ← b .+ 1, b = s is not parsed correctly by @btime, hence the need of f(). On the other hand, it works fine with @time.","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s : a = b .+ 1 b\n# 338.470 ns (3 allocations: 160 bytes)\nf() = @↓ a ← b .+ 1, b = s\n@btime f()\n# 320.763 ns (3 allocations: 160 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Download from nested structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @extract s.c : d e\n# 82.642 ns (0 allocations: 0 bytes)\n@btime @unpack d, e = s.c\n# 52.369 ns (0 allocations: 0 bytes)\n@btime @↓ d, e = s.c\n# 59.402 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/#@-2","page":"Tests","title":"@↑","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"@↓ a, b, c = s\n@↓ e, d = c","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Upload a variable into a struct:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! s = a\n# 54.822 ns (1 allocation: 16 bytes)\n@btime @↑ s = a\n# 21.314 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Upload into a vector of structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! v[1] = a\n# 65.032 ns (1 allocation: 16 bytes)\n@btime @↑ v[1] = a\n# 37.215 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Upload multiple variables:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! s = a, b\n# 70.927 ns (1 allocation: 32 bytes)\n@btime @↑ s = a, b\n# 34.911 ns (0 allocations: 0 bytes)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"Upload into nested structs:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"@btime @pack! s.c = d, e\n# 91.186 ns (1 allocation: 32 bytes)\n@btime @↑ s.c = d, e\n# 57.264 ns (0 allocations: 0 bytes)","category":"page"},{"location":"#ArrowMacros.jl","page":"Home","title":"ArrowMacros.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of ArrowMacros.jl, a Julia package providing the macros @↓ and @↑.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 3","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All exported types and functions are considered part of the public API and thus documented in this manual.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ArrowMacros]","category":"page"},{"location":"#ArrowMacros.@↑-Tuple{Any}","page":"Home","title":"ArrowMacros.@↑","text":"@↑ s = a, b ← f(c)\n\nupload into fields of structs.\n\n\n\n\n\n","category":"macro"},{"location":"#ArrowMacros.@↓-Tuple{Any}","page":"Home","title":"ArrowMacros.@↓","text":"@↓ a, b ← f(c) = s\n\ndownload from fields of structs.\n\n\n\n\n\n","category":"macro"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
